#!/usr/bin/env python
#
# Copyright (c) 2014 CERN
# All Rights Reserved.
#
#    Licensed under the Apache License, Version 2.0 (the "License"); you may
#    not use this file except in compliance with the License. You may obtain
#    a copy of the License at
#
#         http://www.apache.org/licenses/LICENSE-2.0
#
#    Unless required by applicable law or agreed to in writing, software
#    distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
#    License for the specific language governing permissions and limitations
#    under the License.
#

from __future__ import print_function

import argparse
try:
    import configparser
except ImportError:
    import ConfigParser as configparser
import sys

from colorama import Fore, Style
from datetime import datetime
from prettytable import PrettyTable
from sqlalchemy import and_, create_engine, func, MetaData, select, Table
from sqlalchemy.orm import sessionmaker


class project_resource_usage(object):
    def __init__(self, project_id, user_id):
        self.project_id = project_id
        self.user_id = user_id
        self.qu = {
            'instances': 0,
            'cores': 0,
            'ram': 0,
            'security_groups': 0,
            'server_groups': 0,
            'floating_ips': 0}
        self.nu = {
            'instances': 0,
            'cores': 0,
            'ram': 0}
        self.in_sync = True
        self.status = 'OK'

    def update_quota_usage(self, resource, value):
        self.qu[resource] = value

    def update_nova_usage(self, instances, cores, ram):
        self.nu['instances'] = instances
        self.nu['cores'] = cores
        self.nu['ram'] = ram

    def update_sync_status(self):
        for resource in ['instances', 'cores', 'ram']:
            if self.nu[resource] != self.qu[resource]:
                self.in_sync = False
                self.status = 'Mismatch'


def sql_connect(db_url, debug):
    engine = create_engine(db_url, echo=debug)
    conn = engine.connect()
    sessionmaker(bind=engine)
    meta = MetaData()
    meta.bind = engine
    return conn, meta


def sql_disconnect(conn):
    conn.close()


def update_quota_usages(meta, usage):
    if usage['in_sync']:
        print('[ERROR] already in sync')
        return

    instances = 0
    cores = 0
    ram = 0

    for (inst_project_id, inst_user_id, inst_instances, inst_cores, inst_ram) \
            in resources_project_user_usage_projectid(meta,
                                                      usage['project_id']):
        if usage['project_id'] == inst_project_id and \
                usage['user_id'] == inst_user_id:
            instances = inst_instances
            cores = inst_cores
            ram = inst_ram

    instances_quota_usage = 0
    cores_quota_usage = 0
    ram_quota_usage = 0

    quota_usage = resources_project_user_quota_usage(meta,
                                                     usage['project_id'],
                                                     usage['user_id'])

    for (quota_resource, quota_in_use) in quota_usage:
        if quota_resource == 'instances':
            instances_quota_usage = quota_in_use
        elif quota_resource == 'cores':
            cores_quota_usage = quota_in_use
        elif quota_resource == 'ram':
            ram_quota_usage = quota_in_use

    if usage['instances'] != instances or \
            usage['cores'] != cores or \
            usage['ram'] != ram or \
            usage['instances_quota_usage'] != instances_quota_usage or \
            usage['cores_quota_usage'] != cores_quota_usage or \
            usage['ram_quota_usage'] != ram_quota_usage:
        text = '[skipping sync] Values changed in the interim. '
        text += 'project_id:{0} user_id:{1}'.format(usage['project_id'],
                                                    usage['user_id'])
        print(text)
        return

    if usage['instances'] != usage['instances_quota_usage']:
        update_quota_usages_db(meta,
                               usage['project_id'],
                               usage['user_id'],
                               'instances',
                               usage['instances'])
    if usage['cores'] != usage['cores_quota_usage']:
        update_quota_usages_db(meta,
                               usage['project_id'],
                               usage['user_id'],
                               'cores',
                               usage['cores'])
    if usage['ram'] != usage['ram_quota_usage']:
        update_quota_usages_db(meta,
                               usage['project_id'],
                               usage['user_id'],
                               'ram',
                               usage['ram'])


def update_quota_usages_db(meta, project_id, user_id, resource, in_use):
    quota_usages = Table('quota_usages', meta, autoload=True)
    now = datetime.utcnow()
    quota = select(
        columns=[quota_usages.c.user_id],
        whereclause=and_(quota_usages.c.user_id == user_id,
                         quota_usages.c.project_id == project_id,
                         quota_usages.c.resource == resource)
                  ).execute().fetchone()

    if not quota:
        quota_usages.insert().values(
            created_at=now,
            updated_at=now,
            project_id=project_id,
            resource=resource,
            in_use=in_use,
            reserved=0,
            deleted=0,
            user_id=user_id).execute()
    else:
        quota_usages.update().where(
            and_(
                quota_usages.c.user_id == user_id,
                quota_usages.c.project_id == project_id,
                quota_usages.c.resource == resource
                )
            ).values(updated_at=now, in_use=in_use).execute()


def display(resources_usage, all_resources=False):
    ptable = PrettyTable(['Project ID',
                          'User ID',
                          'Instances',
                          'Cores',
                          'Ram',
                          'Status'])

    for usage in resources_usage:
        if not usage['in_sync']:
            if usage['instances'] != usage['instances_quota_usage']:
                instances = str(usage['instances_quota_usage']) + ' -> '
                instances += str(usage['instances'])
            else:
                instances = usage['instances']
            if usage['cores'] != usage['cores_quota_usage']:
                cores = str(usage['cores_quota_usage']) + ' -> '
                cores += str(usage['cores'])
            else:
                cores = usage['cores']
            if usage['ram'] != usage['ram_quota_usage']:
                ram = str(usage['ram_quota_usage']) + ' -> '
                ram += str(usage['ram'])
            else:
                ram = usage['ram']

            ptable.add_row([usage['project_id'],
                            usage['user_id'],
                            instances,
                            cores,
                            ram,
                            Fore.RED + 'Mismatch' + Style.RESET_ALL])

        if usage['in_sync'] and all_resources:
            ptable.add_row([usage['project_id'],
                            usage['user_id'],
                            usage['instances'],
                            usage['cores'],
                            usage['ram'],
                            Fore.GREEN + 'OK' + Style.RESET_ALL])
    print('\n')
    print(ptable)


def check_sync(resources_usage):
    for usage in resources_usage:
        if usage['instances'] != usage['instances_quota_usage'] or \
                usage['cores'] != usage['cores_quota_usage'] or \
                usage['ram'] != usage['ram_quota_usage']:
            usage['in_sync'] = False
    return resources_usage


def get_resource_usage(meta, project=None):
    resource_usage = []

    if project is None:
        projects_q = query_projects_using_quota(meta)
    else:
        projects_q = query_projects_using_quota(meta, project)

    all_instances_q = query_instances(meta)
    all_quota_usages_q = query_quota_usages(meta)

    for project_id, user_id in projects_q:
        if user_id is None:
            continue
#            print(project_id)

        quota_usages = {
            'instances': 0,
            'cores': 0,
            'ram': 0,
            'security_groups': 0,
            'server_groups': 0,
            'floating_ips': 0,
        }

        quota_usages_q = [x for x in all_quota_usages_q if
                          x['project_id'] == project_id and
                          x['user_id'] == user_id]
        for _, _, resource, usage in quota_usages_q:
            quota_usages[resource] += usage

        try:
            resources = dict([x for x in all_instances_q if
                              x['project_id'] == project_id and
                              x['user_id'] == user_id][0])
            resources['instances_quota_usage'] = quota_usages['instances']
            resources['cores_quota_usage'] = quota_usages['cores']
            resources['ram_quota_usage'] = quota_usages['ram']
            resources['in_sync'] = True
            resource_usage.append(resources)
        except IndexError:
            resource_usage.append({
                'user_id': user_id,
                'project_id': project_id,
                'instances': 0,
                'cores': 0,
                'ram': 0,
                'instances_quota_usage': quota_usages['instances'],
                'cores_quota_usage': quota_usages['cores'],
                'ram_quota_usage': quota_usages['ram'],
                'in_sync': True})

    return resource_usage


def query_projects_using_quota(meta, project_id=None):
    quota_usages = Table('quota_usages', meta, autoload=True)

    q = select(
        columns=[
            quota_usages.c.project_id,
            quota_usages.c.user_id])

    if project_id is not None:
        q = q.where(quota_usages.c.project_id == project_id)

    q = q.group_by(
        quota_usages.c.project_id,
        quota_usages.c.user_id)

    return q.execute().fetchall()


def query_instances(meta):
    instances = Table('instances', meta, autoload=True)

    q = select(
        columns=[
            instances.c.project_id,
            instances.c.user_id,
            func.count(instances.c.id).label('instances'),
            func.sum(instances.c.vcpus).label('cores'),
            func.sum(instances.c.memory_mb).label('ram')])

    q = q.where(instances.c.deleted == 0)

    q = q.group_by(
        instances.c.project_id,
        instances.c.user_id)

    return q.execute().fetchall()


def query_quota_usages(meta):
    quota_usages = Table('quota_usages', meta, autoload=True)

    q = select(
        columns=[
            quota_usages.c.project_id,
            quota_usages.c.user_id,
            quota_usages.c.resource,
            func.sum(quota_usages.c.in_use).label('in_use')])

    q = q.where(quota_usages.c.deleted == 0)

    q = q.group_by(
        quota_usages.c.project_id,
        quota_usages.c.user_id,
        quota_usages.c.resource)

    return q.execute().fetchall()


def sync_resources(meta, resources):
    for resource in resources:
        if not resource.in_sync:
            update_quota_usages(meta, resource)


def get_nova_db_url(config_file):
    parser = configparser.SafeConfigParser()
    try:
        parser.read(config_file)
        nova_db_url = parser.get('database', 'connection')
    except Exception as e:
        text = '[ERROR] cannot parse nova configuration file: {0}'.format(e)
        print(text)
        sys.exit(2)
    return nova_db_url


def parse_cmdline_args():
    parser = argparse.ArgumentParser()
    parser.add_argument(
        '-a', '--all',
        action='store_true',
        default=False,
        help='show the state of all quota resources')
    parser.add_argument(
        '-s', '--sync',
        action='store_true',
        default=False,
        help='perform synchronization of mismatched resources')
    parser.add_argument(
        '-p', '--project',
        type=str,
        help='operate only on this project ID')
    parser.add_argument(
        '-c', '--config',
        default='/etc/nova/nova.conf',
        help='path to nova configuration file')
    parser.add_argument(
        '-d', '--debug',
        action='store_true',
        default=False,
        help='enable debug mode')
    return parser.parse_args()


def main():
    args = parse_cmdline_args()
    nova_db_url = get_nova_db_url(args.config)
    conn, meta = sql_connect(nova_db_url, args.debug)
    resources = get_resource_usage(meta, args.project)
    if args.sync:
        sync_resources(meta, resources)
    display(resources, args.all)
    sql_disconnect(conn)


if __name__ == '__main__':
    main()
